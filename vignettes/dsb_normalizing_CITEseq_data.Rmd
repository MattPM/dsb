---
title: "dsb_normalizing_CITEseq_data"
output: rmarkdown::html_vignette
author: MPM
vignette: >
  %\VignetteIndexEntry{normalizing CITEseq data with the DSB package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Detailed usage of the DSB package for normalizing CITEseq data 

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r}
library(dsb)
suppressMessages(library(dplyr))
suppressMessages(library(magrittr))
```


## required format of input data

```{r}
class(cells_citeseq_mtx)
cells_citeseq_mtx[27:37,1:2]
```


You can see above that the input data is a matrix with cells as columns. The non normalized the protein assay of a Seurat object or Single Cell Experiment object is often a sparse matrix. You can easily convert it into a matrix

```{r, eval = FALSE}
# 
r_matrix = as.matrix(sparse_matrix)
```


Empty drops are formatted the same way. This is a direct measurement of experimental noise that we correct for with the dsb normalization method. 
```{r}

empty_drop_citeseq_mtx[27:37,1:2]

```


## Get a vector of isotype control proteins 
```{r}
# protein names in the example data
rownames(cells_citeseq_mtx)

# the isotype controls are index 67 - 70 
isotypes = rownames(cells_citeseq_mtx)[67:70]
isotypes 

```

## Full usage 
This will take about 8 seconds on a laptop.
```{r setup}


# the isotypes were defined above 
# isotypes = c("Mouse IgG2bkIsotype_PROT", "MouseIgG1kappaisotype_PROT","MouseIgG2akappaisotype_PROT", "RatIgG2bkIsotype_PROT")
normalized_matrix = DSBNormalizeProtein(cell_protein_matrix = cells_citeseq_mtx,
                                        empty_drop_matrix = empty_drop_citeseq_mtx,
                                        use.isotype.control = TRUE,
                                        isotype.control.name.vec = isotypes)
# examine the normalized values. 
normalized_matrix[27:37,1:2]

```


## plot protieins on biaxial gates

```{r}

# to plot the data in ggplot we need to make the proteins the variables (columns)
data.plot = normalized_matrix %>% t %>%
  as.data.frame() %>% 
  dplyr::select(CD4_PROT, CD8_PROT, CD27_PROT, CD19_PROT) 

library(ggplot2)
ggplot(data.plot, aes(x = CD4_PROT, y = CD8_PROT)) +
  geom_point(size = 0.2) + 
  geom_density_2d(color = "black") +
  theme_bw()

```

By using the distribution of negative droplets to rescale the counts, directly accounting for experimentally measured noise, as well as using the per cell denoising covariate defined as the mean of the background counts per cell, this reduces noise that negatively influences custering results causing spurious clusters to form (see the preprint)


## Integration with Seurat (also see package readme)


## How do I get the empty droplets?

There are a number of ways to get the empty drops. If you are using cell hashing, when you demultiplex the cells, you get a vector of empty or Negative droplets. 

HTODemux function in Seurat:
https://satijalab.org/seurat/v3.1/hashing_vignette.html

deMULTIplex function from Multiseq (this is now also implemented in Seurat). 
https://github.com/chris-mcginnis-ucsf/MULTI-seq

If you're not multiplexing
you can simply get a vector of negative droplets from the cells you would remove. 
https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1662-y


## Simple example workflow (Seurat Version 3)

```{r, eval=FALSE}

# get the ADT counts using Seurat version 3 
seurat_object = HTODemux(seurat_object, assay = "HTO", positive.quantile = 0.99)
Idents(seurat_object) = "HTO_classification.global"
neg_object = subset(seurat_object, idents = "Negative")
singlet_object = subset(seurat_object, idents = "Singlet")


# non sparse CITEseq data actually store better in a regular materix so the as.matrix() call is not memory intensive.
neg_adt_matrix = GetAssayData(neg_object, assay = "CITE", slot = 'raw.data') %>% as.matrix()
positive_adt_matrix = GetAssayData(singlet_object, assay = "CITE", slot = 'raw.data') %>% as.matrix()


# normalize the data with dsb
# make sure you've run devtools::install_github(repo = 'MattPM/dsb')
normalized_matrix = DSBNormalizeProtein(cell_protein_matrix = positive_adt_matrix,
                                        empty_drop_matrix = neg_adt_matrix)


# now add the normalized dat back to the object (the singlets defined above as "object")
singlet_object = SetAssayData(object = singlet_object, slot = "CITE", new.data = normalized_matrix)




```


As an additional QC step one can confirm the cells called as "Negative" have low RNA / gene content to be certain there are no contaminating cells. 

Also it is not necessary but we reccomend hash demultiplexing with the raw output from cellranger rather than the processed output (i.e. outs/raw_feature_bc_matrix) will have more empty droplets from which the HTODemux function will be able to estimate the negative distribution. This will also have the benefit of creating more droplets to use as built protein background controls in the DSB function. 
 
## example workflow Seurat version 2

```{r, eval=FALSE}

# get the ADT counts using Seurat version 3 
seurat_object = HTODemux(seurat_object, assay = "HTO", positive.quantile = 0.99)

neg = seurat_object %>%
  SetAllIdent(id = "hto_classification_global") %>% 
  SubsetData(ident.use = "Negative") 

singlet = seurat_object %>%
  SetAllIdent(id = "hto_classification_global") %>% 
  SubsetData(ident.use = "Singlet") 

# get negative and positive ADT data 
neg_adt_matrix = neg@assay$CITE@raw.data %>% as.matrix()
pos_adt_matrix = singlet@assay$CITE@raw.data %>% as.matrix()


# normalize the data with dsb
# make sure you've run devtools::install_github(repo = 'MattPM/dsb')
normalized_matrix = DSBNormalizeProtein(cell_protein_matrix = pos_adt_matrix,
                                        empty_drop_matrix = neg_adt_matrix)


# add the assay to the Seurat object 
singlet = SetAssayData(object = singlet, slot = "CITE", new.data = normalized_matrix)


```

  
## How to get empty drops without cell hashing or sample demultiplexing
you can simply get a vector of negative droplets from the cells you would remove. There robust ways to estimate which cells are empty droplets: 
https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1662-y

Below is a quick method to get outlier empty droplets assuming seurat_object is a object with most cells (i.e. any cell expressing at least a gene). 

```{r, eval=FALSE}
# get the nUMI from a seurat version 3 object 
umi = seurat_object$nUMI

#  Get the nUMI from a Seurat version 2 objec 
umi = seurat_object@meta.data %>% select("nUMI")
mu_umi = mean(umi)
sd_umi = sd(umi)

# calculate a threshold for calling a cell negative 
sub_threshold = mu_umi - (5*sd_umi)



Idents(seurat_object) = "nUMI"


# gdefine the negative cell object
neg = subset(seurat_object, accept.high = sub_threshold)


```

This negative cell object can be used to define the negative background following the examples above. 


